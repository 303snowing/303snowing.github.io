<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>kubeadm 实现细节 - 303snowing</title>
  <meta charset="UTF-8">
  <meta name="description" content="303snowing的博客">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="kubeadm init 和 kubeadm join 为从头开始创建一个 Kubernetes 集群的最佳实践共同提供了一个很好的用户体验。但是，kubeadm 如何 做到这一点可能并不明显。">
<meta property="og:type" content="article">
<meta property="og:title" content="kubeadm 实现细节">
<meta property="og:url" content="https://github.com/303snowing/303snowing.github.io/2022/01/21/kubeadm-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/">
<meta property="og:site_name" content="303snowing">
<meta property="og:description" content="kubeadm init 和 kubeadm join 为从头开始创建一个 Kubernetes 集群的最佳实践共同提供了一个很好的用户体验。但是，kubeadm 如何 做到这一点可能并不明显。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-21T03:18:21.000Z">
<meta property="article:modified_time" content="2022-01-21T08:45:14.726Z">
<meta property="article:author" content="303snowing">
<meta property="article:tag" content="K8S">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
  <link rel="stylesheet" href="/css/style.css?v=1652664765170">
  
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_2492588_6aklf99w93e.css">
  
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1652664765170">
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/303snowing/303snowing.github.io@hexo-img/bg.jpeg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="303snowing" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/303snowing/303snowing.github.io@hexo-img/head-icon.jpg" alt="303snowing"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="303snowing">
            <img src="https://cdn.jsdelivr.net/gh/303snowing/303snowing.github.io@hexo-img/head-icon.jpg" alt="303snowing" alt="303snowing">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>10</div>
        <div><span>标签</span>8</div>
        <div><span>分类</span>6</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/resume/resume_java" title="我的简历">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的简历
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:303snowing.github.io" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=jXaWd3W3" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="/null" target="_blank" mdui-tooltip="{content: '&lt;img src=https://cdn.jsdelivr.net/gh/303snowing/303snowing.github.io@hexo-img/wechat.png width=100 height=100/&gt;'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/176335655" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/303snowing/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/K8S/">K8S</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Kali-Linux/">Kali Linux</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Linux/">Linux</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/golang/">golang</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/hexo/">hexo</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/法律法规/">法律法规</a>
          <span class="category-list-count">2</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/K8S/" style="font-size: 20px;">K8S</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF/" style="font-size: 10px;">个人信息</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/" style="font-size: 10px;">数据安全</a> <a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">渗透测试</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">编程</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>



  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2022/05/13/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%B3%95/">数据安全法</a>
          </li>
        
          <li>
            <a href="/2022/05/12/%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4%E6%B3%95/">个人信息保护法</a>
          </li>
        
          <li>
            <a href="/2022/04/22/Linux-%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90-SUID-SGID-SBIT/">Linux 特殊权限 SUID,SGID,SBIT</a>
          </li>
        
          <li>
            <a href="/2022/01/24/Kubernete%E7%BB%84%E4%BB%B6/">Kubernete组件</a>
          </li>
        
          <li>
            <a href="/2022/01/21/kubeadm-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/">kubeadm 实现细节</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 303snowing
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">

  <article>
    
        <div class="nexmoe-post-cover" style="padding-bottom: NaN%;"> 
            <img data-src="https://cdn.jsdelivr.net/gh/303snowing/303snowing.github.io@hexo-img/202201201613432.png" data-sizes="auto" alt="kubeadm 实现细节" class="lazyload">
            <h1>kubeadm 实现细节</h1>
        </div>
    
    
    <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年01月21日</a>
    <a><i class="nexmoefont icon-areachart"></i>7.2k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 32 分钟</a>
</div>

    

    <p>kubeadm init 和 kubeadm join 为从头开始创建一个 Kubernetes 集群的最佳实践共同提供了一个很好的用户体验。但是，kubeadm 如何 做到这一点可能并不明显。</p>
<span id="more"></span>
<h1 id="核心设计原则"><a href="#核心设计原则" class="headerlink" title="核心设计原则"></a>核心设计原则</h1><p>使用 kubeadm init 和 kubeadm join 设置的集群应该：</p>
<ul>
<li>安全：<ul>
<li>它应该采用最新的最佳做法，如：<ul>
<li>强制实施 RBAC</li>
<li>使用节点授权器</li>
<li>控制平面组件之间使用安全通信</li>
<li>API server 和 kubelet 之间使用安全通信</li>
<li>锁定 kubelet API</li>
<li>锁定对系统组件（如 kube-proxy 和 kube-dns）的 API 访问权限</li>
<li>锁定引导令牌可以访问的内容</li>
<li>等等</li>
</ul>
</li>
</ul>
</li>
<li>使用方便：<ul>
<li>用户只需运行几个命令即可：<ul>
<li>kubeadm init</li>
<li>export KUBECONFIG=/etc/kubernetes/admin.conf</li>
<li>kubectl apply -f <network-of-choice.yaml></li>
<li>kubeadm join —token <token> <master-ip>:<master-port></li>
</ul>
</li>
</ul>
</li>
<li>可扩展：<ul>
<li>例如，它不应该支持任何网络提供商，相反，配置网络应该是超出了它的范围</li>
<li>应该提供使用配置文件自定义各种参数的可能性</li>
</ul>
</li>
</ul>
<h1 id="常量和众所周知的值和路径"><a href="#常量和众所周知的值和路径" class="headerlink" title="常量和众所周知的值和路径"></a>常量和众所周知的值和路径</h1><p>为了降低复杂性并简化 kubeadm 实施的部署解决方案的开发，kubeadm 使用一组有限的常量值，用于众所周知的路径和文件名。</p>
<p>Kubernetes 目录 /etc/kubernetes 在应用中是一个常量，因为它明显是大多数情况下的给定路径，也是最直观的位置; 其他常量路径和文件名是：</p>
<ul>
<li>/etc/kubernetes/manifests 作为 kubelet 寻找静态 Pod 的路径。静态 Pod 清单的名称是：<ul>
<li>etcd.yaml</li>
<li>kube-apiserver.yaml</li>
<li>kube-controller-manager.yaml</li>
<li>kube-scheduler.yaml</li>
</ul>
</li>
<li>/etc/kubernetes/ 作为存储具有控制平面组件标识的 kubeconfig 文件的路径。kubeconfig 文件的名称是：<ul>
<li>kubelet.conf （bootstrap-kubelet.conf - 在 TLS 引导期间）</li>
<li>controller-manager.conf</li>
<li>scheduler.conf</li>
<li>admin.conf 用于集群管理员和 kubeadm 本身</li>
</ul>
</li>
<li>证书和密钥文件的名称：<ul>
<li>ca.crt，ca.key 为 Kubernetes 证书颁发机构</li>
<li>apiserver.crt，apiserver.key 用于 API server 证书</li>
<li>apiserver-kubelet-client.crt，apiserver-kubelet-client.key 用于由 API server 安全地连接到 kubelet 的客户端证书</li>
<li>sa.pub，sa.key 用于签署 ServiceAccount 时控制器管理器使用的密钥</li>
<li>front-proxy-ca.crt，front-proxy-ca.key 用于前台代理证书颁发机构</li>
<li>front-proxy-client.crt，front-proxy-client.key 用于前端代理客户端</li>
</ul>
</li>
</ul>
<h1 id="kubeadm-init-工作流程内部设计"><a href="#kubeadm-init-工作流程内部设计" class="headerlink" title="kubeadm init 工作流程内部设计"></a>kubeadm init 工作流程内部设计</h1><p>kubeadm init 内部工作流程 由一系列要执行的原子工作任务组成，如 kubeadm init 所述。</p>
<p>kubeadm alpha phase 命令允许用户单独调用每个任务，并最终提供可重用和可组合的 API/工具箱，可供其他 Kubernetes 引导工具、任何 IT 自动化工具或高级用户创建自定义集群使用。</p>
<h2 id="预检检查"><a href="#预检检查" class="headerlink" title="预检检查"></a>预检检查</h2><p>Kubeadm 在启动 init 之前执行一组预检检查，目的是验证先决条件并避免常见的集群启动问题。在任何情况下，用户都可以使用 <code>--ignore-preflight-errors</code> 选项跳过特定的预检检查（或最终所有预检检查）。</p>
<ul>
<li>[警告]如果要使用的 Kubernetes 版本（与 <code>--kubernetes-version</code> 标记一起指定）至少比 kubeadm CLI 版本高一个次要版本</li>
<li>Kubernetes 系统要求：<ul>
<li>如果在 Linux 上运行：<ul>
<li>[错误] 如果不是 Kernel 3.10+ 或具有特定 KernelSpec 的 4+</li>
<li>[错误] 如果需要的 cgroups 子系统没有设置</li>
</ul>
</li>
<li>如果使用 docker：<ul>
<li>[警告/错误] 如果 Docker 服务不存在，如果它被禁用，如果它不是 active 状态</li>
<li>[错误] 如果 Docker 端点不存在或不起作用</li>
<li>[警告] 如果 docker 版本 &gt; 17.03</li>
</ul>
</li>
<li>如果使用其他 cri 引擎：<ul>
<li>[错误] 如果 crictl 没有响应</li>
</ul>
</li>
</ul>
</li>
<li>[错误] 如果用户不是root用户</li>
<li>[错误] 如果机器主机名不是有效的 DNS 子域</li>
<li>[警告] 如果通过网络查找无法到达主机名</li>
<li>[错误] 如果 kubelet 版本低于 kubeadm 支持的最小 kubelet 版本（当前小版本 -1）</li>
<li>[错误] 如果 kubelet 版本至少比所需的控制平面版本更高一些（不受支持的版本）</li>
<li>[警告] 如果 kubelet 服务不存在或禁用</li>
<li>[警告] 如果 firewalld 处于活动状态</li>
<li>[错误] 如果 API server 的 bindPort 或者 port 10250/10251/10252 已经被使用</li>
<li>[错误] 如果/etc/kubernetes/manifest 文件夹已经存在，并且非空</li>
<li>[错误] 如果 /proc/sys/net/bridge/bridge-nf-call-iptables 文件不存在或者不包含 1</li>
<li>[错误] 如果发布地址是 ipv6 并且 /proc/sys/net/bridge/bridge-nf-call-ip6tables 不存在或者不包含 1</li>
<li>[错误] 如果 swap 打开</li>
<li>[错误] 如果 ip、iptables、mount 或者 nsenter 命令没有出现在命令路径中</li>
<li>[警告] 如果 ebtables、ethtool、socat、tc、touch 和 crictl 命令没有出现在命令路径中</li>
<li>[警告] 如果 API server、Controller-manager、Scheduler 的额外参数中包含一些无效的选项</li>
<li>[警告] 如果连接到 <a href="https://API.AdvertiseAddress:API.BindPort">https://API.AdvertiseAddress:API.BindPort</a> 需要通过代理</li>
<li>[警告] 如果连接到服务子网需要通过代理（只检查第一个地址）</li>
<li>[警告] 如果连接到 pod 子网需要通过代理（只检查第一个地址）</li>
<li>如果提供外部 etcd：<ul>
<li>[错误] 如果 etcd 版本低于 3.0.14</li>
<li>[错误] 如果指定了 etcd 证书或密钥，但未提供</li>
</ul>
</li>
<li>如果不提供外部 etcd（因此将安装本地 etcd）：<ul>
<li>[错误] 如果使用端口 2379</li>
<li>[错误] 如果 Etcd.DataDir 文件夹已经存在并且不是空的</li>
</ul>
</li>
<li>如果授权模式是 ABAC：<ul>
<li>[错误] 如果 abac_policy.json 不存在</li>
</ul>
</li>
<li>如果授权模式是 WebHook：<ul>
<li>[错误] 如果 webhook_authz.conf 不存在</li>
</ul>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>预检检查可以通过 kubeadm alpha phase preflight 命令单独调用</li>
</ol>
<h2 id="生成必要的证书"><a href="#生成必要的证书" class="headerlink" title="生成必要的证书"></a>生成必要的证书</h2><p>Kubeadm 为不同目的生成证书和私钥对:</p>
<ul>
<li>Kubernetes 集群的自签名证书颁发机构保存到 ca.crt 文件和 ca.key 私钥文件中</li>
<li>API server 的服务证书，使用 ca.crt 作为 CA 生成，并保存到 apiserver.crt 文件中，并带有其私钥 apiserver.key。此证书应包含以下其他名称：<ul>
<li>Kubernetes 服务的内部 clusterIP（服务 CIDR 中的第一个地址，例如，如果服务子网是 10.96.0.0/12 则为 10.96.0.1）</li>
<li>Kubernetes DNS 名称，例如，如果 —service-dns-domain 标志的值为 cluster.local，则为 kubernetes.default.svc.cluster.local，再加上默认的 DNS 名称 kubernetes.default.svc、kubernetes.default 和 kubernetes</li>
<li>节点名称</li>
<li>—apiserver-advertise-address</li>
<li>由用户指定的其他替代名称</li>
</ul>
</li>
<li>用于 API server 的安全连接到 kubelet 的客户端证书，使用 ca.crt 作为 CA 生成并使用私钥 apiserver-kubelet-client.key 保存到文件 apiserver-kubelet-client.crt中。这个证书应该在 system:masters 组织中</li>
<li>一个用于签名 ServiceAccount 令牌的私钥，该令牌与它的公钥 sa.pub 一起保存到 sa.key 文件中。</li>
<li>前端代理的证书颁发机构保存到 front-proxy-ca.crt 文件中，其密钥为 front-proxy-ca.key</li>
<li>前端代理客户端的客户证书，使用 front-proxy-ca.crt 作为 CA 生成，并使用其私钥 front-proxy-client.key 保存到 front-proxy-client.crt 文件中</li>
</ul>
<p>证书默认存储在 /etc/kubernetes/pki 中，但该目录可使用 —cert-dir 标志进行配置。</p>
<p>请注意：</p>
<ol>
<li>如果给定的证书和私钥对都存在，并且其内容评估符合上述规范，则将使用现有文件并跳过给定证书的生成阶段。这意味着用户可以将现有 CA 复制到 /etc/kubernetes/pki/ca.{crt,key}，然后 kubeadm 将使用这些文件来签署剩余的证书。请参与 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-certificates">使用自定义证书</a></li>
<li>只有 CA 可以提供 ca.crt 文件，但不提供 ca.key 文件，如果所有其他证书和 kubeconfig 文件已就位，kubeadm 会识别此情况并激活 ExternalCA，这也意味着 controller-manager 中的 csrsigner 控制器将不会启动</li>
<li>如果 kubeadm 在 ExternalCA 模式下运行; 所有的证书都必须由用户提供，因为 kubeadm 本身不能生成它们</li>
<li>在 —dry-run 模式中执行 kubeadm 的情况下，证书文件被写入临时文件夹中</li>
<li>使用 kubeadm alpha phase certs all 命令可以单独调用证书生成动作</li>
</ol>
<h2 id="为控制平面组件生成-kubeconfig-文件"><a href="#为控制平面组件生成-kubeconfig-文件" class="headerlink" title="为控制平面组件生成 kubeconfig 文件"></a>为控制平面组件生成 kubeconfig 文件</h2><p>具有控制平面组件标识的 Kubeadm kubeconfig 文件：</p>
<ul>
<li>kubelet 使用的 kubeconfig 文件：/etc/kubernetes/kubelet.conf; 在这个文件内嵌入一个具有 kubelet 身份的客户端证书。这个客户证书应该：<ul>
<li>在 system:nodes 组织中，符合 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/156.html">节点授权</a> 模块的要求</li>
<li>有 CN system:node:<hostname-lowercased></li>
</ul>
</li>
<li>controller-manager 使用的 kubeconfig 文件：/etc/kubernetes/controller-manager.conf; 在这个文件内嵌入一个带有 controller-manager 身份的客户端证书。此客户端证书应具有 CN system:kube-controller-manager，默认由 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/148.html">RBAC 核心组件角色</a> 定义</li>
<li>scheduler 使用的 kubeconfig 文件：/etc/kubernetes/scheduler.conf; 在这个文件内嵌入一个带有 scheduler 标识的客户端证书。此客户端证书应具有 CN system:kube-scheduler，默认由 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/148.html">RBAC 核心组件角色</a> 定义</li>
</ul>
<p>此外，生成一个 kubeadm 去使用它自己以及管理员使用的 kubeconfig 文件，并保存到 /etc/kubernetes/admin.conf 文件中。这里的 “管理员” 定义了正在管理集群并希望完全控制（root）集群的实际人员。管理员的嵌入式客户端证书应该：</p>
<ul>
<li>在 system:masters 组织中，默认由 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/148.html">RBAC 用户所面对的角色绑定</a> 定义</li>
<li>包括一个 CN，但可以是任何东西。Kubeadm 使用 kubernetes-admin CN</li>
</ul>
<p>请注意：</p>
<ol>
<li>ca.crt 证书嵌入在所有 kubeconfig 文件中。</li>
<li>如果给定的 kubeconfig 文件存在，并且其内容的评估符合上述规范，则将使用现有文件，并跳过给定 kubeconfig 的生成阶段</li>
<li>如果 kubeadm 以 ExternalCA 模式运行，则所有必需的 kubeconfig 也必须由用户提供，因为 kubeadm 本身不能生成它们中的任何一个</li>
<li>如果在 —dry-run 模式下执行 kubeadm ，kubeconfig 文件将写入临时文件夹中</li>
<li>使用 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-alpha/#cmd-phase-kubeconfig">kubeadm alpha phase kubeconfig all</a> 命令可以单独调用 Kubeconfig 文件生成动作</li>
</ol>
<h2 id="为控制平面组件生成静态-Pod-清单"><a href="#为控制平面组件生成静态-Pod-清单" class="headerlink" title="为控制平面组件生成静态 Pod 清单"></a>为控制平面组件生成静态 Pod 清单</h2><p>kubeadm 将控制平面组件的静态 Pod 清单文件写入 /etc/kubernetes/manifests; Kubelet 会监控这个目录，在启动时创建 pod。</p>
<p>静态 Pod 清单共享一组通用属性：</p>
<ul>
<li>所有静态 Pod 都部署在 kube-system 命名空间上</li>
<li>所有静态 Pod 都可以获取 tier:control-plane 和 component:{component-name} 标记</li>
<li>所有的静态 Pod 都会获得 scheduler.alpha.kubernetes.io/critical-pod 注解（这将转移到适当的解决方案，即在准备就绪时使用 pod 优先级和抢占）</li>
<li>在所有静态 Pod 上设置 hostNetwork: true，以便在网络配置之前允许控制平面启动; 因此：<ul>
<li>controller-manager 和 scheduler 使用来指代该 API server 的地址为 127.0.0.1</li>
<li>如果使用本地 etcd 服务器，etcd-servers 地址将被设置为 127.0.0.1:2379</li>
</ul>
</li>
<li>controller-manager 和 scheduler 均启用选举</li>
<li>controller-manager 和 scheduler 将引用 kubeconfig 文件及其各自的唯一标识</li>
<li>所有静态 Pod 都会获得用户指定的额外标志，如 将自定义参数传递给控制平面组件 所述</li>
<li>所有静态 Pod 都会获取用户指定的任何额外卷（主机路径）</li>
</ul>
<p>请注意：</p>
<ol>
<li><code>--kubernetes-version</code> 当前体系结构中的所有镜像 将从中 gcr.io/google_containers 中拉取; 如果指定了其他镜像仓库库或 CI 镜像仓库，则将使用此仓库; 如果一个特定的容器镜像应该被用于所有控制平面组件，那么这个特定镜像将被使用。请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">使用自定义镜像</a> 了解更多详情</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则将静态 Pod 文件写入临时文件夹</li>
<li>可以使用 <code>kubeadm alpha phase controlplane all</code> 命令单独调用生成主组件的静态 Pod 清单</li>
</ol>
<h2 id="API-server"><a href="#API-server" class="headerlink" title="API server"></a>API server</h2><p>API server 的静态 Pod 清单受用户提供的以下参数的影响：</p>
<ul>
<li>需要指定要绑定到的 <code>apiserver-advertise-address</code> 和 <code>apiserver-bind-port</code>；如果没有提供，这些值分别默认为机器上默认网络接口的 IP 地址和端口 6443</li>
<li><code>service-cluster-ip-range</code> 用于服务</li>
<li>如果指定了外部 etcd 服务器，则要设定 <code>etcd-servers</code>地址和相关的 TLS 设置（<code>etcd-cafile</code>、<code>etcd-certfile</code>、<code>etcd-keyfile</code>）; 如果不提供外部 etcd 服务器，则会使用本地 etcd（通过主机网络）</li>
<li>如果指定了云提供商，则要配置相应的 <code>--cloud-provider</code>，如果这样的文件存在，还要配置 <code>--cloud-config</code> 路径（这是实验性的、alpha 功能，将在未来的版本中删除）</li>
<li>如果 kubeadm 被调用为 <code>--feature-gates=HighAvailability</code>，则标志 <code>--endpoint-reconciler-type=lease</code> 被设置，从而启用内部 API server VIP 的 endpoints 的自动协调</li>
<li>如果 kubeadm 被调用为 <code>--feature-gates=DynamicKubeletConfig</code>，则 API 服务器上的相应功能将通过 <code>--feature-gates=DynamicKubeletConfig=true</code> 标志激活</li>
</ul>
<p>其他无条件设置的 API server 标志是：</p>
<ul>
<li><code>--insecure-port=0</code> 避免与 api server 的不安全连接</li>
<li><code>--enable-bootstrap-token-auth=true</code> 启用 BootstrapTokenAuthenticator 验证模块。有关更多详细信息，请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/admin/kubelet-tls-bootstrapping.md">TLS 引导</a></li>
<li><code>--allow-privileged</code> 为 true （如 kube proxy 所要求的）</li>
<li><code>--requestheader-client-ca-file</code> 为 front-proxy-ca.crt</li>
<li><code>--admission-control</code> 为：<ul>
<li>Initializers 启用 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/144.html">动态准入控制</a></li>
<li>NamespaceLifecycle 例如避免删除系统保留的命名空间</li>
<li>LimitRanger 和 ResourceQuota 强制限制命名空间</li>
<li><a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/709.html">ServiceAccount</a> 强制执行服务帐户自动化</li>
<li><a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/admin/admission-controllers/#persistentvolumelabel">PersistentVolumeLabel</a> 将区域或区域标签附加到由云提供商定义的 PersistentVolumes （此准入控制器已被弃用，并将在未来的版本中被删除。没有明确选择使用 gce 或 aws 作为云提供商时，它在默认情况下跟 1.9 版本一样，并不是由 kubeadm 部署）</li>
<li>DefaultStorageClass 在 PersistentVolumeClaim 对象上强制执行默认存储类</li>
<li>DefaultTolerationSeconds</li>
<li>NodeRestriction 限制 kubelet 可以修改的内容（例如，只有该节点上的 pod）</li>
</ul>
</li>
<li><code>--kubelet-preferred-address-types</code> 为 InternalIP,ExternalIP,Hostname;，这使得 kubectl logs 和其他 api server-kubelet 通信能够在节点主机名不可解析的环境中工作。</li>
<li>使用先前步骤中生成的证书的标志：<ul>
<li><code>--client-ca-file</code> 为 ca.crt</li>
<li><code>--tls-cert-file</code> 为 apiserver.crt</li>
<li><code>--tls-private-key-file</code> 为 apiserver.key</li>
<li><code>--kubelet-client-certificate</code> 为 apiserver-kubelet-client.crt</li>
<li><code>--kubelet-client-key</code> 为 apiserver-kubelet-client.key</li>
<li><code>--service-account-key-file</code> 为 sa.pub</li>
<li><code>--requestheader-client-ca-file</code>为front-proxy-ca.crt</li>
<li><code>--proxy-client-cert-file</code> 为 front-proxy-client.crt</li>
<li><code>--proxy-client-key-file</code> 为 front-proxy-client.key</li>
</ul>
</li>
<li>用于保护前端代理（API Aggregation）通信的其他标志：<ul>
<li><code>--requestheader-username-headers=X-Remote-User</code></li>
<li><code>--requestheader-group-headers=X-Remote-Group</code></li>
<li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li>
<li><code>--requestheader-allowed-names=front-proxy-client</code></li>
</ul>
</li>
</ul>
<h2 id="Controller-manager"><a href="#Controller-manager" class="headerlink" title="Controller manager"></a>Controller manager</h2><p>API server 的静态 Pod 清单受用户提供的以下参数的影响：</p>
<ul>
<li>如果调用 kubeadm 时指定一个 <code>--pod-network-cidr</code>，某些 CNI 网络插件所需的子网管理器功能可以通过设置来启用：<ul>
<li><code>--allocate-node-cidrs=true</code></li>
<li><code>--cluster-cidr</code> 和 <code>--node-cidr-mask-size</code> 根据给定的 CIDR 标志</li>
</ul>
</li>
<li>如果指定了云提供商，则要配置相应的 <code>--cloud-provider</code>，如果这样的文件存在，还要配置 <code>--cloud-config</code> 路径（这是实验性的、alpha 功能，将在未来的版本中删除）</li>
</ul>
<p>其他无条件设置的标志是：</p>
<ul>
<li><code>--controllers</code> 为 TLS 引导启用所有默认控制器加上 BootstrapSigner 和 TokenCleaner 控制器。有关更多详细信息，请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/admin/kubelet-tls-bootstrapping.md">TLS 引导</a></li>
<li><code>--use-service-account-credentials</code>为 true</li>
<li>使用先前步骤中生成的证书的标志：<ul>
<li><code>--root-ca-file</code> 为 ca.crt</li>
<li><code>--cluster-signing-cert-file</code> 为 ca.crt，如果外部 CA 模式被禁用，则返回 “”</li>
<li><code>--cluster-signing-key-file</code> 为 ca.key，如果外部 CA 模式被禁用，则返回 “”</li>
<li><code>--service-account-private-key-file</code> 为 sa.key</li>
</ul>
</li>
</ul>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>Scheduler 的静态 Pod 清单不受用户提供的参数的影响。</p>
<h2 id="为本地-etcd-生成静态-Pod-清单"><a href="#为本地-etcd-生成静态-Pod-清单" class="headerlink" title="为本地 etcd 生成静态 Pod 清单"></a>为本地 etcd 生成静态 Pod 清单</h2><p>如果用户指定了外部 etcd，则此步骤将被跳过，否则 kubeadm 将生成一个静态的 Pod 清单文件，用于创建在 Pod 中运行的本地 etcd 实例，其中包含以下属性：</p>
<ul>
<li>监听 localhost:2379 并使用 HostNetwork=true</li>
<li>做一个 hostPath，从 dataDir 挂载到 主机文件系统</li>
<li>任何由用户指定的额外标志</li>
</ul>
<p>请注意：</p>
<ol>
<li>etcd 镜像将从中 gcr.io/google_containers 中拉取; 如果指定了其他镜像仓库库，则将使用此仓库; 如果一个特定的容器镜像应该被用于所有控制平面组件，那么这个特定镜像将被使用。请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">使用自定义镜像</a> 了解更多详情</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则将静态 Pod 文件写入临时文件夹</li>
<li>可以使用 <code>kubeadm alpha phase etcd local</code>命令为本地 etcd 生成的静态 Pod 清单</li>
</ol>
<h2 id="编写-init-kubelet-配置"><a href="#编写-init-kubelet-配置" class="headerlink" title="编写 init kubelet 配置"></a>编写 init kubelet 配置</h2><p>如果 kubeadm 被调用为 <code>--feature-gates=DynamicKubeletConfig</code>，它会将 kubelet init 配置写入 <code>/var/lib/kubelet/config/init/kubelet</code> 文件。</p>
<p>init 配置用于在此特定节点上启动 kubelet，为 kubelet 插入文件提供替代方案; 这种配置将被以下步骤中所述的 Kubelet 基本配置替代。请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/tasks/administer-cluster/kubelet-config-file.md">通过配置文件设置 Kubelet 参数</a> 以获取更多信息。</p>
<p>请注意：</p>
<ol>
<li>要使动态 kubelet 配置正常工作，应该在 <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code> 中指定标志 <code>--dynamic-config-dir=/var/lib/kubelet/config/dynamic</code></li>
<li>通过设置<code>.kubeletConfiguration.baseConfig</code>，Kubelet init 配置可以通过使用 kubeadm MasterConfiguration 文件进行修改。请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">在配置文件中使用 kubelet init</a> 以获取更多信息。</li>
</ol>
<h2 id="等待控制平面启动"><a href="#等待控制平面启动" class="headerlink" title="等待控制平面启动"></a>等待控制平面启动</h2><p>这是 kubeadm 集群的关键时刻。kubeadm 等待 localhost:6443/healthz 返回 ok，但是为了检测死锁情况，如果localhost:10255/healthz（kubelet liveness）或 localhost:10255/healthz/syncloop（kubelet readiness）分别在 40 秒和 60 秒后不返回 ok，kubeadm 就会快速失败。</p>
<p>kubeadm 依靠 kubelet 来拉取控制平面镜像，并以静态 Pod 的形式正确运行它们。控制平面启动后，kubeadm 完成以下段落中描述的任务。</p>
<h2 id="编写基本-kubelet-配置"><a href="#编写基本-kubelet-配置" class="headerlink" title="编写基本 kubelet 配置"></a>编写基本 kubelet 配置</h2><p>如果 kubeadm 被调用为 <code>--feature-gates=DynamicKubeletConfig</code>：</p>
<ol>
<li>将 kubelet 基本配置写入命名空间 kube-system 的 kubelet-base-config-v1.9 ConfigMap 中</li>
<li>创建 RBAC 规则来授予该 ConfigMap 对所有引导令牌和所有 kubelet 实例（即组 system:bootstrappers:kubeadm:default-node-token 和 system:nodes）的读访问权限</li>
<li>通过将 Node.spec.configSource 指向新创建的 ConfigMap 来为初始主节点启用动态 kubelet 配置功能</li>
</ol>
<h2 id="将-kubeadm-MasterConfiguration-保存在-ConfigMap-中供以后参考"><a href="#将-kubeadm-MasterConfiguration-保存在-ConfigMap-中供以后参考" class="headerlink" title="将 kubeadm MasterConfiguration 保存在 ConfigMap 中供以后参考"></a>将 kubeadm MasterConfiguration 保存在 ConfigMap 中供以后参考</h2><p>kubeadm 将 kubeadm init 通过标志或配置文件传递给 ConfigMap 的配置保存在 kube-system 命名空间下的 kubeadm-config ConfigMap 中。</p>
<p>这将确保将来（例如 kubeadm upgrade）执行的 kubeadm 行动将能够确定 实际/当前 的集群状态并基于该数据做出新的决定。</p>
<p>请注意：</p>
<ol>
<li>在上传之前，敏感信息（例如令牌）会从配置中删除</li>
<li>主配置的上传可以通过 <code>kubeadm alpha phase upload-config</code> 命令单独调用</li>
<li>如果您使用 kubeadm v1.7.x 或更低版本初始化集群，则必须在使用 kubeadm upgrade 到 v1.8 之前手动创建 master 的配置 ConfigMap 。为了促进这项任务，kubeadm config upload (from-flags|from-file) 已经实施</li>
</ol>
<h2 id="标记-master"><a href="#标记-master" class="headerlink" title="标记 master"></a>标记 master</h2><p>一旦控制平面可用，kubeadm 将执行以下操作：</p>
<ul>
<li>用 <code>node-role.kubernetes.io/master=&quot;&quot;</code> 给 master 增加标签</li>
<li>用 <code>node-role.kubernetes.io/master:NoSchedule</code> 给 master 增加污点</li>
</ul>
<p>请注意：</p>
<ol>
<li>标记 master 阶段可以通过 <code>kubeadm alpha phase mark-master</code> 命令单独调用</li>
</ol>
<h2 id="配置-TLS-引导-以加入节点"><a href="#配置-TLS-引导-以加入节点" class="headerlink" title="配置 TLS-引导 以加入节点"></a>配置 TLS-引导 以加入节点</h2><p>Kubeadm 使用 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/713.html">引导令牌进行身份验证</a> 将新节点连接到现有集群; 欲了解更多详情，请参阅 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">设计方案</a>。</p>
<p>kubeadm init 确保为此过程正确配置所有内容，这包括以下步骤以及设置 API server 和控制器标志，如前面几个段落中所述。</p>
<p>请注意：</p>
<ol>
<li>可以使用 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-alpha/#cmd-phase-bootstrap-token">kubeadm alpha phase bootstrap-token all</a> 命令配置节点的 TLS 引导，执行以下段落中描述的所有配置步骤; 或者，每个步骤都可以单独调用</li>
</ol>
<h3 id="创建一个引导令牌"><a href="#创建一个引导令牌" class="headerlink" title="创建一个引导令牌"></a>创建一个引导令牌</h3><p>kubeadm init 创建第一个引导令牌，可以自动生成或由用户使用<code>--token</code> 标志提供; 在引导令牌规范中，令牌应该保存为命名空间 kube-system 下的 bootstrap-token-<token-id> secret 中。</p>
<p>请注意：</p>
<ol>
<li>通过 kubeadm init 创建的默认令牌将用于 TLS 在引导过程中验证临时用户；这些用户将成为 system:bootstrappers:kubeadm:default-node-token 组的成员</li>
<li>令牌的有效期有限，默认 24 小时（间隔可以使用 —token-ttl 标志变更）</li>
<li>额外的令牌可以使用 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/713.html">kubeadm token</a> 命令创建，它还可以为令牌管理提供其他有用的功能</li>
</ol>
<h3 id="允许加入节点来调用-CSR-API"><a href="#允许加入节点来调用-CSR-API" class="headerlink" title="允许加入节点来调用 CSR API"></a>允许加入节点来调用 CSR API</h3><p>Kubeadm 确保 system:bootstrappers:kubeadm:default-node-token 组中的用户能够访问证书签名 API。</p>
<p>这是通过在上面的组和默认的 RBAC 角色 system:node-bootstrapper 之间创建一个名为 kubeadm:kubelet-bootstrap 的 ClusterRoleBinding 来实现的。</p>
<h3 id="为新的引导令牌设置自动批准"><a href="#为新的引导令牌设置自动批准" class="headerlink" title="为新的引导令牌设置自动批准"></a>为新的引导令牌设置自动批准</h3><p>Kubeadm 确保引导令牌将获得 csrapprover 控制器自动批准的 CSR 请求。</p>
<p>这是通过 system:bootstrappers:kubeadm:default-node-token 组和默认的角色 system:certificates.k8s.io:certificatesigningrequests:nodeclient 之间创建一个名为 kubeadm:node-autoapprove-bootstrap 的 ClusterRoleBinding 来实现的。</p>
<p>角色 system:certificates.k8s.io:certificatesigningrequests:nodeclient 也应该创建，并授予访问 /apis/certificates.k8s.io/certificatesigningrequests/nodeclient 的 POST 权限。</p>
<h3 id="通过自动批准设置节点证书轮换"><a href="#通过自动批准设置节点证书轮换" class="headerlink" title="通过自动批准设置节点证书轮换"></a>通过自动批准设置节点证书轮换</h3><p>Kubeadm 确保为节点启用证书轮换，并且节点的新证书请求将获得由 csrapprover 控制器自动批准的 CSR 请求。</p>
<p>这是通过 system:nodes 组和默认的角色 system:certificates.k8s.io:certificatesigningrequests:selfnodeclient 之间创建一个名为 kubeadm:node-autoapprove-certificate-rotation 的 ClusterRoleBinding 来实现的。</p>
<h3 id="创建公共集群信息-ConfigMap"><a href="#创建公共集群信息-ConfigMap" class="headerlink" title="创建公共集群信息 ConfigMap"></a>创建公共集群信息 ConfigMap</h3><p>此阶段在 kube-public 命名空间中创建 cluster-info ConfigMap。</p>
<p>此外，还创建了一个角色和一个 RoleBinding，为未经身份验证的用户授予对 ConfigMap 的访问权（即 RBAC 组中的用户 system:unauthenticated）</p>
<p>请注意：</p>
<ol>
<li>访问 cluster-info ConfigMap 是不 受限制的。如果您将您的主机暴露在互联网上，这可能是问题，也可能不是问题；最坏的情况是 DoS 攻击，攻击者使用 Kube-apiserver 可以处理的所有请求来为 cluster-info ConfigMap 提供服务。</li>
</ol>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>Kubeadm 通过 API server 安装内部 DNS 服务和 kube-proxy 插件组件。</p>
<p>请注意：</p>
<ol>
<li>这个阶段可以通过 <code>kubeadm alpha phase addon all</code> 命令单独调用</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在命名空间 kube-system 下为 kube-proxy 创建一个 ServiceAccount；然后使用 DaemonSet 部署 kube-proxy：</p>
<ul>
<li>master 的凭证（ca.crt 和 token）来自 ServiceAccount</li>
<li>master 的位置来自 ConfigMap</li>
<li>kube-proxy ServiceAccount 绑定到 system:node-proxier ClusterRole 中的权限</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在命名空间 kube-system 下为 kube-dns 创建一个 ServiceAccount。</p>
<p>部署 kube-dns 的 Deployment 和 Service：</p>
<ul>
<li>这是相对上游来说没有修改的 kube-dns 部署</li>
<li>kube-dns ServiceAccount 绑定到 system:kube-dns ClusterRole 中的权限</li>
</ul>
<p>请注意：</p>
<ol>
<li>如果 kubeadm 被调用为 —feature-gates=CoreDNS，则会安装 CoreDNS 而不是 kube-dns</li>
</ol>
<h2 id="自托管"><a href="#自托管" class="headerlink" title="自托管"></a>自托管</h2><p>只有在 kubeadm init 被调用为 <code>--features-gates=selfHosting</code> 才执行此阶段</p>
<p>自托管阶段基本上用 DaemonSet 取代控制平面组件的静态 Pod; 这是通过执行 API server、scheduler 和 controller manager 静态 Pod 的以下过程来实现的：</p>
<ul>
<li>从磁盘加载静态 Pod 规格</li>
<li>从静态的 Pod 清单文件中提取 PodSpec</li>
<li>改变 PodSpec 与自托管兼容，更详细的内容：<ul>
<li>为带有 <code>node-role.kubernetes.io/master=&quot;&quot;</code> 标签的节点增加节点选择器属性</li>
<li>为污点 <code>node-role.kubernetes.io/master:NoSchedule</code> 增加一个容忍</li>
<li>设置 <code>spec.DNSPolicy</code> 为 <code>ClusterFirstWithHostNet</code></li>
</ul>
</li>
<li>为有问题的自托管组件构建一个新的 DaemonSet 对象。使用上面提到的 PodSpec</li>
<li>在 kube-system 命名空间中创建 DaemonSet 资源。等到 Pod 运行。</li>
<li>删除静态的 Pod 清单文件。kubelet 将停止正在运行的原始静态 Pod 托管组件</li>
</ul>
<p>请注意：</p>
<ol>
<li>自托管尚未恢复到节点重新启动的能力; 这可以通过外部检查点或控制平面 Pod 的 kubelet 检查点来修正。有关更多详细信息，请参阅 <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#self-hosting">自托管</a>。</li>
<li>如果被调用为 <code>--features-gates=StoreCertsInSecrets</code>，以下附加步骤将被执行<ul>
<li>在 kube-system 命名空间下使用各自的证书和秘钥创建 ca、apiserver、apiserver-kubelet-client、sa、front-proxy-ca、front-proxy-client TLS secrets 。重要！将 CA 密钥存储在 Secret 中可能会产生安全隐患</li>
<li>使用各自的 kubeconfig 文件在命名空间 kube-system 中创建 schedler.conf 和 controller-manager.conf secret</li>
<li>通过将主机路径卷替换为上述 secret 中的投影卷，对所有 POD 规范进行变更</li>
</ul>
</li>
<li>这个阶段可以通过 <code>kubeadm alpha phase selfhosting convert-from-staticpods</code> 命令单独调用</li>
</ol>
<h1 id="kubeadm-join-阶段的内部设计"><a href="#kubeadm-join-阶段的内部设计" class="headerlink" title="kubeadm join 阶段的内部设计"></a>kubeadm join 阶段的内部设计</h1><p>与 kubeadm init 类似，kubeadm join 内部工作流也是由一系列要执行的原子工作任务组成。</p>
<p>这分为发现（有 Node 信任 Kubernetes Master）和 TLS 引导（有 Kubernetes Master 信任 Node）。</p>
<p>请参阅 <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/713.html">使用引导令牌进行身份验证</a> 或相应的 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">设计方案</a>。</p>
<h2 id="预检检查-1"><a href="#预检检查-1" class="headerlink" title="预检检查"></a>预检检查</h2><p>kubeadm 在开始连接之前执行一组预检检查，目的是验证先决条件并避免常见的集群启动问题。</p>
<p>请注意：</p>
<ol>
<li>kubeadm join 预检检查基本上是一个 kubeadm init 预检检查的子集</li>
<li>从 1.9 开始，kubeadm 为 CRI 泛型功能提供了更好的支持; 在这种情况下，docker 特定的控件将被跳过或替换为 crictl 类似控件</li>
<li>从 1.9 开始，kubeadm 支持加入运行在 Windows 上的节点; 在这种情况下，会跳过 linux 特定的控制</li>
<li>在任何情况下，用户都可以使用该 —ignore-preflight-errors 选项跳过特定的预检检查（或最终所有预检检查）</li>
</ol>
<h2 id="发现集群信息"><a href="#发现集群信息" class="headerlink" title="发现集群信息"></a>发现集群信息</h2><p>有两个主要的发现方案。首先是使用共享令牌以及 API server 的 IP 地址。第二个是提供一个文件（标准 kubeconfig 文件的一个子集）。</p>
<h2 id="共享令牌发现"><a href="#共享令牌发现" class="headerlink" title="共享令牌发现"></a>共享令牌发现</h2><p>如果 kubeadm join 被调用为 <code>--discovery-token</code>，则使用令牌发现; 在这种情况下，节点基本上从命名空间 kube-public 下 cluster-info ConfigMap 中检索集群 CA 证书 。</p>
<p>为了防止 “中间人” 攻击，采取了几个步骤：</p>
<ul>
<li>首先，通过不安全的连接检索 CA 证书（这是可能的，因为 kubeadm init 对 system:unauthenticated 授予了访问 cluster-info 用户的权限）</li>
<li>然后 CA 证书通过以下验证步骤：<ul>
<li>基本验证：针对 JWT 签名使用令牌 ID</li>
<li>发布密钥验证：使用提供的 <code>--discovery-token-ca-cert-hash</code>。此值可在 kubeadm init 的输出中获取，也可以使用标准工具计算（散列是在 SPKI（Subject Public Key Info）对象的字节上计算的，如 RFC 7469 中所示）。<code>--discovery-token-ca-cert-hash</code> 标志可以重复多次，以允许多个公钥。 -作为附加验证，CA 证书通过安全连接进行检索，然后与最初检索的 CA 进行比较</li>
</ul>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>通过 <code>--discovery-token-unsafe-skip-ca-verification</code> 标志可以跳过发布密钥验证; 这削弱了 kubeadm 安全模型，因为其他人可能潜在模仿 Kubernetes Master。</li>
</ol>
<h2 id="文件-https-发现"><a href="#文件-https-发现" class="headerlink" title="文件/https 发现"></a>文件/https 发现</h2><p>如果 kubeadm join 被调用为 —discovery-file，则使用文件发现; 此文件可以是本地文件或通过 HTTPS URL 下载; 在 HTTPS 的情况下，主机安装的 CA 用于验证连接。</p>
<p>通过文件发现，集群 CA 证书被提供到文件本身; 事实上，发现的文件是一个 kubeconfig 文件，其中只设置了 server 和 certificate-authority-data 属性，如 kubeadm join 参考文档中所述; 当与集群建立连接时，kubeadm 尝试访问 cluster-info ConfigMap，如果可用，则使用它。</p>
<h2 id="TLS-引导"><a href="#TLS-引导" class="headerlink" title="TLS 引导"></a>TLS 引导</h2><p>一旦知道了集群信息，就会编写文件 <code>bootstrap-kubelet.conf</code>，从而允许 kubelet 执行 TLS 引导（相反，直到 v1.7 TLS 引导被 kubeadm 管理）。</p>
<p>TLS 引导机制使用共享令牌临时向 Kubernetes Master 进行身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。</p>
<p>然后自动批准该请求，并且该操作完成保存 ca.crt 文件和用于加入集群的 kubelet.conf 文件，而 bootstrap-kubelet.conf 被删除。</p>
<p>请注意：</p>
<ul>
<li>临时验证是根据 kubeadm init 过程中保存的令牌进行验证的（或者使用 kubeadm token 创建的附加令牌）</li>
<li>对 kubeadm init 过程中被授予访问 CSR api 的 system:bootstrappers:kubeadm:default-node-token 组的用户成员的临时身份验证解析</li>
<li>自动 CSR 审批由 csrapprover 控制器管理，与 kubeadm init 过程的配置相一致</li>
</ul>
<h2 id="编写init-kubelet配置"><a href="#编写init-kubelet配置" class="headerlink" title="编写init kubelet配置"></a>编写init kubelet配置</h2><p>如果 kubeadm 被调用为 <code>--feature-gates=DynamicKubeletConfig</code>：</p>
<ol>
<li>使用引导令牌凭据从 kube-system 命名空间中的 kubelet-base-config-v1.9 ConfigMap 中读取 kubelet 基本配置，并将其写入磁盘，作为 kubelet init 配置文件 /var/lib/kubelet/config/init/kubelet</li>
<li>当 kubelet 以节点自己的凭据（/etc/kubernetes/kubelet.conf）开始时，更新当前节点配置，指定 node/kubelet 配置的源是上面的 ConfigMap。</li>
</ol>
<p>请注意：</p>
<ol>
<li>要使动态 kubelet 配置正常工作，应在 /etc/systemd/system/kubelet.service.d/10-kubeadm.conf 中指定标志 <code>--dynamic-config-dir=/var/lib/kubelet/config/dynamic</code></li>
</ol>

  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>303snowing<br>
    <strong>本文链接：</strong><a href="https://github.com/303snowing/303snowing.github.io/2022/01/21/kubeadm-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/" title="https:&#x2F;&#x2F;github.com&#x2F;303snowing&#x2F;303snowing.github.io&#x2F;2022&#x2F;01&#x2F;21&#x2F;kubeadm-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;github.com&#x2F;303snowing&#x2F;303snowing.github.io&#x2F;2022&#x2F;01&#x2F;21&#x2F;kubeadm-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82&#x2F;</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/K8S/">K8S</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/K8S/" rel="tag">K8S</a>
    
</div>

  <div class="nexmoe-post-footer">
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '4a3e8f198a01684edff6',
        clientSecret: 'b98da32dd0145a9e1e4aad8dc5912b97312895dc',
        id: window.location.pathname,
        repo: '303snowing.github.io',
        owner: '303snowing',
        admin: '303snowing'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool"> 
              
                
              
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>
 

<script async src="/js/app.js?v=1652664765171"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
